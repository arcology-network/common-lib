/*
 *   Copyright (c) 2023 Arcology Network
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package common

func MapForeach[M ~map[K]V, K comparable, V any](source M, do func(k K, v *V)) {
	for k, v := range source {
		do(k, &v)
	}
}

// MapRemoveIf removes key-value pairs from a map based on a condition.
func MapRemoveIf[M ~map[K]V, K comparable, V any](source M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			delete(source, k)
		}
	}
}

// MapMoveIf moves key-value pairs from one map to another based on a condition.
func MapMoveIf[M ~map[K]V, K comparable, V any](source, target M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			target[k] = v
			delete(source, k)
		}
	}
}

// MergeMaps merges the key-value pairs from one map into another map.
func MergeMaps[M ~map[K]V, K comparable, V any](from, to M) M {
	for k, v := range to {
		from[k] = v
	}
	return from
}

// MapFromArray creates a map from an array of keys, with all values set to a specified value.
func MapFromArray[K comparable, V any](keys []K, v V) *map[K]V {
	M := make(map[K]V)
	for _, k := range keys {
		M[k] = v
	}
	return &M
}

// MapFromArrayBy creates a map from an array of values, with keys generated by a getter function,
// and all values set to a specified initial value.
func MapFromArrayBy[K comparable, T, V any](keys []T, initv V, getter func(t T) K) *map[K]V {
	M := make(map[K]V)
	for _, k := range keys {
		M[getter(k)] = initv
	}
	return &M
}

// MapKeys returns a slice containing all the keys of a map.
func MapKeys[M ~map[K]V, K comparable, V any](m M) []K {
	keys := make([]K, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// MapValues returns a slice containing all the values of a map.
func MapValues[M ~map[K]V, K comparable, V any](m M) []V {
	values := make([]V, len(m))
	i := 0
	for _, v := range m {
		values[i] = v
		i++
	}
	return values
}

// MapKVs takes a map as input and returns two slices, one containing the keys and the other containing the values of the map.
func MapKVs[M ~map[K]V, K comparable, V any](m M) ([]K, []V) {
	keys := make([]K, len(m))
	values := make([]V, len(m))
	i := 0
	for k, v := range m {
		keys[i] = k
		values[i] = v
		i++
	}
	return keys, values
}
