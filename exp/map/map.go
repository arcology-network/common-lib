/*
 *   Copyright (c) 2023 Arcology Network
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package mapi

func Foreach[M ~map[K]V, K comparable, V any](source M, do func(k K, v *V)) {
	for k, v := range source {
		do(k, &v)
	}
}

// RemoveIf removes key-value pairs from a map based on a condition.
func RemoveIf[M ~map[K]V, K comparable, V any](source M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			delete(source, k)
		}
	}
}

// MoveIf moves key-value pairs from one map to another based on a condition.
func MoveIf[M ~map[K]V, K comparable, V any](source, target M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			target[k] = v
			delete(source, k)
		}
	}
}

// Merges merges the key-value pairs from one map into another map.
func Merge[M ~map[K]V, K comparable, V any](from, to M) M {
	for k, v := range to {
		from[k] = v
	}
	return from
}

// FromArray creates a map from an array of keys, with all values set to a specified value.
func FromArray[K comparable, V any](keys []K, setter func(K) V) map[K]V {
	M := make(map[K]V)
	for _, k := range keys {
		M[k] = setter(k)
	}
	return M
}

// FromArrayBy creates a map from an array of values, with keys generated by a getter function,
// and all values set to a specified initial value.
func FromArrayBy[K comparable, T, V any](source []T, getter func(i int, t T) (K, V)) map[K]V {
	M := make(map[K]V)
	for i, src := range source {
		k, v := getter(i, src)
		M[k] = v
	}
	return M
}

// Keys returns a slice containing all the keys of a map.
func Keys[M ~map[K]V, K comparable, V any](m M) []K {
	keys := make([]K, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// Values returns a slice containing all the values of a map.
func Values[M ~map[K]V, K comparable, V any](m M) []V {
	values := make([]V, len(m))
	i := 0
	for _, v := range m {
		values[i] = v
		i++
	}
	return values
}

// KVs takes a map as input and returns two slices, one containing the keys and the other containing the values of the map.
func KVs[M ~map[K]V, K comparable, V any](m M) ([]K, []V) {
	keys := make([]K, len(m))
	values := make([]V, len(m))
	i := 0
	for k, v := range m {
		keys[i] = k
		values[i] = v
		i++
	}
	return keys, values
}
