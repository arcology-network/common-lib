/*
 *   Copyright (c) 2023 Arcology Network
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package mapi

import slice "github.com/arcology-network/common-lib/exp/slice"

func Foreach[M ~map[K]V, K comparable, V any](source M, do func(k K, v *V)) {
	for k, v := range source {
		do(k, &v)
	}
}

func IfFoundDo[M ~map[K]V, K comparable, V any](source M, keys []K, new func(k K, v *V) V) {
	for _, k := range keys {
		if v, ok := source[k]; ok {
			source[k] = new(k, &v)
		}
	}
}

func ParalleIfFoundDo[M ~map[K]V, K comparable, V any](source M, keys []K, threads int, new func(k K) V) {
	found := slice.ParallelTransform(keys, threads, func(_ int, k K) bool {
		_, ok := source[k]
		return ok
	})

	for i := range found {
		if found[i] {
			source[keys[i]] = new(keys[i])
		}
	}
}

func IfNotFoundDo[M ~map[K]V, K comparable, V any, T any](source M, keys []T, getter func(T) K, do func(K) V) {
	for _, k := range keys {
		realK := getter(k)
		if _, ok := source[realK]; !ok {
			source[realK] = do(realK)
		}
	}
}

func ParallelIfNotFoundDo[M ~map[K]V, K comparable, V any](source M, keys []K, threads int, do func(k K) V) {
	found := slice.ParallelTransform(keys, threads, func(_ int, k K) bool {
		_, ok := source[k]
		return ok
	})

	for i := range found {
		if !found[i] {
			source[keys[i]] = do(keys[i])
		}
	}
}

// RemoveIf removes key-value pairs from a map based on a condition.
func RemoveIf[M ~map[K]V, K comparable, V any](source M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			delete(source, k)
		}
	}
}

// MoveIf moves key-value pairs from one map to another based on a condition.
func MoveIf[M ~map[K]V, K comparable, V any](source, target M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			target[k] = v
			delete(source, k)
		}
	}
}

// Merges merges the key-value pairs from one map into another map.
func Merge[M ~map[K]V, K comparable, V any](from, to M) M {
	for k, v := range to {
		from[k] = v
	}
	return from
}

// Sub substracts the key-value pairs from one map into another map.
func Sub[M ~map[K]V, K comparable, V any](from, to M) M {
	for k := range to {
		delete(from, k)
	}
	return from
}

// Sub substracts the key-value pairs from one map into another map.
func EqualIf[M ~map[K]V, K comparable, V any](m0, m1 M, equal func(v0 V, v1 V) bool) bool {
	if len(m0) != len(m1) {
		return false
	}

	for k, v0 := range m1 {
		if v1, ok := m0[k]; !ok || !equal(v0, v1) {
			return false
		}
	}
	return true
}

// FromSlice creates a map from an array of keys, with all values set to a specified value.
func FromSlice[K comparable, V any](keys []K, setter func(K) V) map[K]V {
	M := make(map[K]V)
	for _, k := range keys {
		M[k] = setter(k)
	}
	return M
}

// FromSliceBy creates a map from an array of values, with keys generated by a getter function,
// and all values set to a specified initial value.
func FromSliceBy[K comparable, T, V any](source []T, getter func(i int, t T) (K, V)) map[K]V {
	M := make(map[K]V)
	return Insert(M, source, getter)
}

// Insert inserts key-value pairs from an array into a map.
func Insert[K comparable, T, V any](mp map[K]V, source []T, getter func(i int, t T) (K, V)) map[K]V {
	for i, src := range source {
		k, v := getter(i, src)
		mp[k] = v
	}
	return mp
}

// Keys returns a slice containing all the keys of a map.
func Keys[M ~map[K]V, K comparable, V any](m M) []K {
	keys := make([]K, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// Values returns a slice containing all the values of a map.
func KeysToBuffer[M ~map[K]V, K comparable, V any](m M, buffer *[]K) []K {
	i := 0
	for k, _ := range m {
		(*buffer)[i] = k
		i++
	}
	return (*buffer)
}

// Values returns a slice containing all the values of a map.
func Values[M ~map[K]V, K comparable, V any](m M) []V {
	values := make([]V, len(m))
	i := 0
	for _, v := range m {
		values[i] = v
		i++
	}
	return values
}

// Values returns a slice containing all the values of a map.
func ValuesToBuffer[M ~map[K]V, K comparable, V any](m M, buffer *[]V) []V {
	i := 0
	for _, v := range m {
		(*buffer)[i] = v
		i++
	}
	return (*buffer)
}

// KVs takes a map as input and returns two slices, one containing the keys and the other containing the values of the map.
func KVs[M ~map[K]V, K comparable, V any](m M) ([]K, []V) {
	keys := make([]K, len(m))
	values := make([]V, len(m))
	i := 0
	for k, v := range m {
		keys[i] = k
		values[i] = v
		i++
	}
	return keys, values
}

func KVsToBuffer[M ~map[K]V, K comparable, V any](m M, keys *[]K, values *[]V) ([]K, []V) {
	for k, v := range m {
		*keys = append(*keys, k)
		*values = append(*values, v)
	}
	return *keys, *values
}

// Keys returns a slice containing all the keys of a map.
func ContainsAny[M ~map[K]V, K comparable, V any](m M, keys []K) bool {
	for _, k := range keys {
		if _, ok := m[k]; ok {
			return true
		}
	}
	return false
}

// Keys returns a slice containing all the keys of a map.
func FindKey[M ~map[K]V, K comparable, V any](m M, less func(K, K) bool) (K, V) {
	var mink K
	var minv V
	var init bool
	for k, v := range m {
		if !init {
			mink = k
			minv = v
			init = true
			continue
		}

		if less(k, mink) {
			mink = k
			minv = v
		}
	}
	return mink, minv
}

// // Keys returns a slice containing all the keys of a map.
// func MaxKey[M ~map[K]V, K comparable, V any](m M, greater func(K, K) bool) (K, V) {
// 	var maxk K
// 	var maxv V
// 	var init bool
// 	for k, v := range m {
// 		if !init {
// 			maxk = k
// 			maxv = v
// 			init = true
// 			continue
// 		}

// 		if greater(k, maxk) {
// 			maxk, maxv = k, v
// 		}
// 	}
// 	return maxk, maxv
// }

func FindValue[M ~map[K]V, K comparable, V any](m M, less func(V, V) bool) (K, V) {
	var mink K
	var minv V
	var init bool
	for k, v := range m {
		if !init {
			mink = k
			minv = v
			init = true
			continue
		}

		if less(v, minv) {
			mink, minv = k, v
		}
	}
	return mink, minv
}

// // Keys returns a slice containing all the keys of a map.
// func MinValue[M ~map[K]V, K comparable, V any](m M, less func(V, V) bool) (K, V) {
// 	var mink K
// 	var minv V
// 	var init bool
// 	for k, v := range m {
// 		if !init {
// 			mink = k
// 			minv = v
// 			init = true
// 			continue
// 		}

// 		if less(v, minv) {
// 			mink, minv = k, v
// 		}
// 	}
// 	return mink, minv
// }

// // Keys returns a slice containing all the keys of a map.
// func MaxValue[M ~map[K]V, K comparable, V any](m M, greater func(V, V) bool) (K, V) {
// 	var maxk K
// 	var maxv V
// 	var init bool
// 	for k, v := range m {
// 		if !init {
// 			maxk = k
// 			maxv = v
// 			init = true
// 			continue
// 		}

// 		if greater(v, maxv) {
// 			maxk, maxv = k, v
// 		}
// 	}
// 	return maxk, maxv
// }
