/*
 *   Copyright (c) 2023 Arcology Network
 *   All rights reserved.

 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at

 *   http://www.apache.org/licenses/LICENSE-2.0

 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package mapi

import "github.com/arcology-network/common-lib/exp/array"

func Foreach[M ~map[K]V, K comparable, V any](source M, do func(k K, v *V)) {
	for k, v := range source {
		do(k, &v)
	}
}

func IfFoundDo[M ~map[K]V, K comparable, V any](source M, keys []K, new func(k K, v *V) V) {
	for _, k := range keys {
		if v, ok := source[k]; ok {
			source[k] = new(k, &v)
		}
	}
}

func ParalleIfFoundDo[M ~map[K]V, K comparable, V any](source M, keys []K, threads int, new func(k K) V) {
	found := array.ParallelAppend(keys, threads, func(_ int, k K) bool {
		_, ok := source[k]
		return ok
	})

	for i := range found {
		if found[i] {
			source[keys[i]] = new(keys[i])
		}
	}
}

func IfNotFoundDo[M ~map[K]V, K comparable, V any, T any](source M, keys []T, getter func(T) K, do func(K) V) {
	for _, k := range keys {
		realK := getter(k)
		if _, ok := source[realK]; !ok {
			source[realK] = do(realK)
		}
	}
}

func ParallelIfNotFoundDo[M ~map[K]V, K comparable, V any](source M, keys []K, threads int, do func(k K) V) {
	found := array.ParallelAppend(keys, threads, func(_ int, k K) bool {
		_, ok := source[k]
		return ok
	})

	for i := range found {
		if !found[i] {
			source[keys[i]] = do(keys[i])
		}
	}
}

// RemoveIf removes key-value pairs from a map based on a condition.
func RemoveIf[M ~map[K]V, K comparable, V any](source M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			delete(source, k)
		}
	}
}

// MoveIf moves key-value pairs from one map to another based on a condition.
func MoveIf[M ~map[K]V, K comparable, V any](source, target M, condition func(k K, v V) bool) {
	for k, v := range source {
		if condition(k, v) {
			target[k] = v
			delete(source, k)
		}
	}
}

// Merges merges the key-value pairs from one map into another map.
func Merge[M ~map[K]V, K comparable, V any](from, to M) M {
	for k, v := range to {
		from[k] = v
	}
	return from
}

// FromArray creates a map from an array of keys, with all values set to a specified value.
func FromArray[K comparable, V any](keys []K, setter func(K) V) map[K]V {
	M := make(map[K]V)
	for _, k := range keys {
		M[k] = setter(k)
	}
	return M
}

// FromArrayBy creates a map from an array of values, with keys generated by a getter function,
// and all values set to a specified initial value.
func FromArrayBy[K comparable, T, V any](source []T, getter func(i int, t T) (K, V)) map[K]V {
	M := make(map[K]V)
	return Insert(M, source, getter)
}

// Insert inserts key-value pairs from an array into a map.
func Insert[K comparable, T, V any](mp map[K]V, source []T, getter func(i int, t T) (K, V)) map[K]V {
	for i, src := range source {
		k, v := getter(i, src)
		mp[k] = v
	}
	return mp
}

// Keys returns a slice containing all the keys of a map.
func Keys[M ~map[K]V, K comparable, V any](m M) []K {
	keys := make([]K, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

// Values returns a slice containing all the values of a map.
func KeysToBuffer[M ~map[K]V, K comparable, V any](m M, buffer *[]K) []K {
	i := 0
	for k, _ := range m {
		(*buffer)[i] = k
		i++
	}
	return (*buffer)
}

// Values returns a slice containing all the values of a map.
func Values[M ~map[K]V, K comparable, V any](m M) []V {
	values := make([]V, len(m))
	i := 0
	for _, v := range m {
		values[i] = v
		i++
	}
	return values
}

// Values returns a slice containing all the values of a map.
func ValuesToBuffer[M ~map[K]V, K comparable, V any](m M, buffer *[]V) []V {
	i := 0
	for _, v := range m {
		(*buffer)[i] = v
		i++
	}
	return (*buffer)
}

// KVs takes a map as input and returns two slices, one containing the keys and the other containing the values of the map.
func KVs[M ~map[K]V, K comparable, V any](m M) ([]K, []V) {
	keys := make([]K, len(m))
	values := make([]V, len(m))
	i := 0
	for k, v := range m {
		keys[i] = k
		values[i] = v
		i++
	}
	return keys, values
}

func KVsToBuffer[M ~map[K]V, K comparable, V any](m M, keys *[]K, values *[]V) ([]K, []V) {
	for k, v := range m {
		*keys = append(*keys, k)
		*values = append(*values, v)
	}
	return *keys, *values
}

// Keys returns a slice containing all the keys of a map.
func ContainsAny[M ~map[K]V, K comparable, V any](m M, keys []K) bool {
	for _, k := range keys {
		if _, ok := m[k]; ok {
			return true
		}
	}
	return false
}
